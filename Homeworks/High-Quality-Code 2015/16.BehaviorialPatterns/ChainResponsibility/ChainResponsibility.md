### Chain resposibility pattern



1. **Описание**

 Този патерн позволява на клиента да рабори с един обект/клас,
 към който да дава заявка а тя да бъде обработена. Начинът, по който се обработва
 заявката е следния: след като тя е предадена на първия обект, ако той не може да 
 обработи заявката, тя се предава на втория и така докато някой по веригата обработи завката.
 Много подобно на Exception Handling. Ако заявката не може да се обработи от никой по веригата 
 то следва в последния обработил я да съобщи за грешка.

2. **Предимства:**
 * Подреденост откъм начина на обработка на заявката
 * Всеки знае за следващия
 * Лесно добавяене на нови обекти за обработка, поради факта, че всички наследяват базов клас.

3. **Други характерисики**
    
 Всеки обект знае за следващия и за предишния,
 първия, койт обработи заявката прекъсва веригата.
 Възможни са вериги от дървета, но са по-сложни и съответно по-малко използвани.
 Ако трябва да се представа като дърво то трябва да се разглежда така:
 клиента има връзка с едно от листата, а завката се предава нагоре към върха т.е. обратно на 
 наследяването. От значение е последователността на обработката на заявката.

4. **Диаграми**

 Представям две диаграми от придружаващия код. Едната е класическа диаграма .cd, другата е малко по-
 шарена но там се огромния coopling между обектите(манджа). На втората ако се загледате по-внимателно
 може да видите точната връзка на патерна. 

5. **Демо**

 В предоставеното демо е показано приложение проверяващо за картите дали има някаква `ръка` - чифт,
 поредни, флъш и т.н. Създаването на `ръка` се състои от 5 `карти`, от които всяка съдържа `боя` и `число` като 
 пропъртита. Създават се няколко `ръце` и класове за проверка, като преди самата проверка се настройват *кой да е следващия
 по веригата, който да обработи заявката*. Винаги се започва от този с проверка за най-голяма ръка. Защо? Защото не 
 е логично да проверяваш от най-малката ръка(най-висока карта) която винаги ще прекъсва в началото на веригат и се губи смисъла.